# Numpy入门

标签： 科学计算库 Numpy Python

2018 07 23
---

n维数组 ndrray 非常牛逼

有很多数学函数，实用的线性代数福利也变换和随机生成数
支持高维度

##  一、操作NDARRAY多维数组

因为标准python非常傻，虽然list可以当作数组来用，但是非常费内存和cpu；自带的array模块也只支持一维数组，可以说非常的傻了
因此引入numpy来进行数值运算。

### ndarray（N-dimensional array object）N维数组对象。
作为一个快速而灵活的大数据集容器，由两部分组成：
实际的数据； 描述这些数据的元数据。
大部分的数组操作仅仅修改原数据部分，而不改变底层实际数据。而且ndarray所有的元素的类型必须是一致的。

```python
import numpy as np
#创建一个ndarray数组
ndArr2 = np.arange(5)      # range(5)
ndArr2
 # output:array([0, 1, 2, 3, 4])
#对ndarry中的每个元素取平方
ndArr2 = ndArr2 ** 2
ndArr2
 # output:
 array([ 0,  1,  4,  9, 16], dtype=int32)
 
 ndArr3 = np.arange(5)**3
ndArr3
 # output:
 array([ 0,  2, 12, 36, 80], dtype=int32)
```

获取对象的维度和类型：
```python
print(a.shape)
print(a.dtype)
```

创建多位维数组

```python
import numpy as np
#用 numpy的通用函数创建
a = np.arange(1,21,2,dtype = np.int64)
a
# array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19], dtype=int64)

# 通过： np.array（）传入Python列表创建
arr = np.array([6,5,4,3,2,1])
arr
 # array([6, 5, 4, 3, 2, 1])
```

其他方法创建：
```python
a = np.zeros((2,2))  # 创建一个值均为零的2x2的ndarray对象  （第一个参数为行数，第二个为列数
b = np.ones((1,2))   # 创建一个值均为1的1x2的ndarray对象
c = np.full((2,2),7) # 创建一个值均为7的2x2的ndarray对象
d = np.eye(2)        # 创建一个2x2单位矩阵
e = np.eye(3, k=2)   
# 第一个参数为方阵的边长，第二个参数为正则右上方平移对角线，为负数则像左下方平移，k为平移位数。
```
## 二、数组的索引和切片
索引：即通过一个无符号整数获取数组里的值，Python中的索引是从0的位置开始
切片：即对数组里某个片段的描述

### 1.索引：
一维数组的索引和Python列表的功能类似。
二维数组的索引：
1. 当以一维数组的索引方式访问一个二维数组的时候，获取到的元素不是一个标量而是一个一维数组（第某行）。
2. 以二维数组的索引方式访问的话，则会获得标量，数组名([行号][列号])，或者 数组名（[行号，列号]）。
三维数组的索引：
参照二维数组的访问方式
### 2.切片：
一维数组的切片与Python列表的功能很相似。
语法形式：
a[起点:终点:步长]  a[::-1] 负数下标反转数组
多维数组的切片：
1. reshape改变维度 .reshape(行数,列数,层数) 
2. 语法形式： 维度之间用"," ，一维数组内用":"，参数顺序：层，行，列




## 三、改变数组的维度

### 改变数组的维度：
.reshape(层,行,列)   # 不修改原数组
.resize(层,行,列)    # 直接修改原数组

### 展平数组：
.revel() 方法，返回一个多维数组的一维视图，不改变原数组
.flatten() 同上，但是不改变原数组，请求内内存来存放新数组
### 转置数组：
.transpose() 

## 四、数组的组合和分割
 Numpy数组有水平组合，垂直组合和深度组合等多种组合方式，方法有：vatack dstack hstack column_stack row_stack 以及concatenate函数来完成数组的组合。
 

### 1.数组的组合：
 1. 水平组合 ```hstack((array1, array2))``` 或者```concatenate((array1, array2), axis = 1)``` 横向拼接,就是array2的行接到array1的行后面。
 2. 垂直组合```vstack((array1, array2))``` 或者 ```concatenatel((array1, array2), axis = 0)```
 纵向拼接，即将array2的列接到array1的下面。
 3. 深度组合 ```datack((array1, array2))```, 按索引相同组成行，没行数据组成新列，每列数据变成新层。
 4. 列组合 ```column_stack```函数对于一维数组将按列方向进行组合，对于二维数组```column_stack```和```hstack```效果相同
 5. 行组合```row_stack```函数将按行方向进行组和的函数，对于二维数组，```row_stack```和```vstack``` 效果是相同的。


### 2.数组的分割

1. 水平分割 将数组沿着水平方向分割为3个相同大小的子数组，分割的结果为列向量
    1. 可利用```np.split(arr, 3, axis = 1) ```(按行分割）
    2. 可利用```np.hsplit(arr, 3)```（按列分割）
2. 垂直分割 把数据沿着垂直方向分割（分割结果为行向量）
    1. 可利用```np.split(arr, 3, axis = 0)``` （按行分）
    2. 可利用```np.vsplit(arr, 3)``` 跟上面那个一样
3. 深度分割
```python
# 按深度方向分割数组
arr1 = np.arange(8).reshape(2,2,2)
print(arr1)
print()
result5 = np.dsplit(arr1, 2)
print(result5[0])
print(result5[1])
```
output:
[[[0 1]
  [2 3]]

 [[4 5]
  [6 7]]]
 // 原数组
[[[0]
  [2]]

 [[4]
  [6]]]
[[[1]
  [3]]

 [[5]
  [7]]]
 // 分成了两个 相当于把立方体从中间切开了。
 
### 3.数组的属性
1. ndim属性 给出数组的维数，或数组轴的个数
2. size属性 给出数组元素的总个数
3. itemsize属性 给出数组中的元素内存中所占的字节
4. nbytes属性 给出整个数组所占的存储空间
5. T属性  矩阵转置
6. imag属性 给出复数数组的虚部
7. real属性 给出复数数组的实部

## 题目
 1.创建一个一维数组，将其倒置，输出结果
 
```python
ANarr = np.arange(8)
```
>array([0, 1, 2, 3, 4, 5, 6, 7])
```python
di_ANarr = ANarr[::-1]
```
>array([7, 6, 5, 4, 3, 2, 1, 0])

2.创建一个行值是0到4的5x5矩阵：

```python
# 方法一：
arr = np.arange(5)
np.vstack((arr, arr, arr, arr, arr))
```
>array([[0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4]])
```python
# 方法二：
arrOrg = np.zeros((5,5))
arr = np.arange(5)
arrOrg[:] = arr
arrOrg
```
>array([[0., 1., 2., 3., 4.],
       [0., 1., 2., 3., 4.],
       [0., 1., 2., 3., 4.],
       [0., 1., 2., 3., 4.],
       [0., 1., 2., 3., 4.]])

3.创建一个10x10数组，边框为1，里面为0

```python
zero10[0,] = 1
zero10[-1,]= 1
zero10[:,0] = 1
zero10[:,-1]= 1
zero10
```
>array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
